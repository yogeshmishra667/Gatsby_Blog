{"componentChunkName":"component---src-templates-blog-js","path":"/blog/nodejs","webpackCompilationHash":"","result":{"data":{"contentfulBlogPost":{"title":"Basic node.js","publishedData":"October 8th 2019","body":{"json":{"data":{},"content":[{"data":{},"content":[{"data":{},"marks":[],"value":"About node.js","nodeType":"text"}],"nodeType":"heading-2"},{"data":{},"content":[{"data":{},"marks":[],"value":"As an asynchronous event-driven JavaScript runtime, Node.js is designed to build scalable network applications. In the following \"hello world\" example, many connections can be handled concurrently. Upon each connection, the callback is fired, but if there is no work to be done, Node.js will sleep.","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[{"type":"code"}],"value":"const http = require('http');\n\nconst hostname = '127.0.0.1';const port = 3000;\n\nconst server = http.createServer((req, res) => {\n  res.statusCode = 200;\n  res.setHeader('Content-Type', 'text/plain');\n  res.end('Hello World\\n');});\n\nserver.listen(port, hostname, () => {\n  console.log(`Server running at http://${hostname}:${port}/`);});\n","nodeType":"text"},{"data":{},"marks":[],"value":"\nThis is in contrast to today's more common concurrency model, in which OS threads are employed. Thread-based networking is relatively inefficient and very difficult to use. Furthermore, users of Node.js are free from worries of dead-locking the process, since there are no locks. Almost no function in Node.js directly performs I/O, so the process never blocks. Because nothing blocks, scalable systems are very reasonable to develop in Node.js.","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"Node.js is similar in design to, and influenced by, systems like Ruby's ","nodeType":"text"},{"data":{"uri":"https://github.com/eventmachine/eventmachine"},"content":[{"data":{},"marks":[],"value":"Event Machine","nodeType":"text"}],"nodeType":"hyperlink"},{"data":{},"marks":[],"value":" and Python's ","nodeType":"text"},{"data":{"uri":"https://twistedmatrix.com/trac/"},"content":[{"data":{},"marks":[],"value":"Twisted","nodeType":"text"}],"nodeType":"hyperlink"},{"data":{},"marks":[],"value":". Node.js takes the event model a bit further. It presents an ","nodeType":"text"},{"data":{"uri":"https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/"},"content":[{"data":{},"marks":[],"value":"event loop","nodeType":"text"}],"nodeType":"hyperlink"},{"data":{},"marks":[],"value":" as a runtime construct instead of as a library. In other systems, there is always a blocking call to start the event-loop. Typically, behavior is defined through callbacks at the beginning of a script, and at the end a server is started through a blocking call like ","nodeType":"text"},{"data":{},"marks":[{"type":"code"}],"value":"EventMachine::run()","nodeType":"text"},{"data":{},"marks":[],"value":". In Node.js, there is no such start-the-event-loop call. Node.js simply enters the event loop after executing the input script. Node.js exits the event loop when there are no more callbacks to perform. This behavior is like browser JavaScript — the event loop is hidden from the user.\n\n\n\n\n\n","nodeType":"text"}],"nodeType":"paragraph"},{"data":{},"content":[{"data":{},"marks":[],"value":"","nodeType":"text"}],"nodeType":"paragraph"}],"nodeType":"document"}},"slug":"nodejs"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"nodejs"}}}